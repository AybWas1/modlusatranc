<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modlu Satranç - Bot Edition</title>
    <style>
        :root { --light: #ebecd0; --dark: #779556; --select: #ffff33; }
        body { margin: 0; background: #1a1a1a; color: white; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        #container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        
        /* Karelerin yamulmasını engelleyen sabit grid */
        #board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            width: 400px; height: 400px;
            border: 5px solid #333;
            user-select: none;
        }

        .square { width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; position: relative; cursor: pointer; }
        .light { background: var(--light); }
        .dark { background: var(--dark); }
        .piece { font-size: 40px; z-index: 5; line-height: 1; filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.4)); }
        .selected { background-color: var(--select) !important; }
        .dot { width: 12px; height: 12px; background: rgba(0,0,0,0.2); border-radius: 50%; position: absolute; z-index: 2; }

        #side { min-width: 180px; display: flex; flex-direction: column; gap: 10px; }
        .panel { background: #252525; padding: 15px; border-radius: 8px; text-align: center; border: 1px solid #444; }
        #pool { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
        #pool span { font-size: 28px; background: #333; border-radius: 5px; padding: 5px; cursor: pointer; border-bottom: 2px solid #000; }
        #pool span.disabled { opacity: 0.1; pointer-events: none; }
        #pool span.active { background: #779556 !important; }

        #overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 100; flex-direction: column; align-items: center; justify-content: center; }
        #overlay button { margin-top: 20px; padding: 10px 20px; cursor: pointer; background: #779556; border: none; color: white; border-radius: 5px; }
    </style>
</head>
<body>

    <div id="overlay">
        <h1 id="win-text">BEYAZ KAZANDI!</h1>
        <button onclick="location.reload()">Tekrar Oyna</button>
    </div>

    <h2 style="margin: 0 0 15px 0">♟️ Modlu Satranç (Bot'a Karşı)</h2>

    <div id="container">
        <div id="board"></div>
        <div id="side">
            <div class="panel" id="turn">SIRA: SENDE</div>
            <div class="panel" id="score">B: 0 | S: 0</div>
            <div id="pool" class="panel"></div>
        </div>
    </div>

    <script>
        window.onload = () => {
            const boardEl = document.getElementById("board");
            const poolEl = document.getElementById("pool");
            const turnEl = document.getElementById("turn");
            const scoreEl = document.getElementById("score");
            const overlay = document.getElementById("overlay");
            const winText = document.getElementById("win-text");

            const PIECES = {
                p: { s: "♙", c: 1 }, n: { s: "♘", c: 3 }, b: { s: "♗", c: 3 },
                r: { s: "♖", c: 5 }, q: { s: "♕", c: 9 }, k: { s: "♔", c: 0 }
            };

            let board = [...Array(8)].map(() => Array(8).fill(null));
            board[0][0] = { t: "k", c: "w" }; 
            board[7][7] = { t: "k", c: "b" }; 

            let turn = "w"; // w: Oyuncu (Beyaz), b: Bot (Siyah)
            let score = { w: 0, b: 0 };
            let selected = null;
            let moves = [];
            let placing = null;

            function draw() {
                boardEl.innerHTML = "";
                for (let y = 7; y >= 0; y--) {
                    for (let x = 0; x < 8; x++) {
                        const sq = document.createElement("div");
                        sq.className = `square ${(x + y) % 2 ? "dark" : "light"}`;
                        const p = board[x][y];
                        if (p) {
                            const sp = document.createElement("div");
                            sp.className = "piece";
                            if (selected && selected.x === x && selected.y === y) sq.classList.add("selected");
                            sp.textContent = PIECES[p.t].s;
                            sp.style.color = p.c === "w" ? "#fff" : "#000";
                            sq.appendChild(sp);
                        }
                        if (moves.some(m => m.x === x && m.y === y) || (placing && !p)) {
                            const d = document.createElement("div");
                            d.className = "dot";
                            sq.appendChild(d);
                        }
                        sq.onclick = () => turn === "w" && click(x, y);
                        boardEl.appendChild(sq);
                    }
                }
                turnEl.textContent = turn === "w" ? "SIRA: SENDE" : "SIRA: BOT...";
                scoreEl.innerHTML = `PUAN<br>SEN: ${score.w} | BOT: ${score.b}`;
                drawPool();
            }

            function drawPool() {
                poolEl.innerHTML = "";
                for (const k in PIECES) {
                    if (k === "k") continue;
                    const s = document.createElement("span");
                    s.textContent = PIECES[k].s;
                    if (PIECES[k].c > score[turn]) s.className = "disabled";
                    if (placing === k) s.className = "active";
                    s.onclick = (e) => {
                        if(turn !== "w") return;
                        e.stopPropagation();
                        placing = (placing === k) ? null : k;
                        selected = null; moves = [];
                        draw();
                    };
                    poolEl.appendChild(s);
                }
            }

            function getMoves(x, y, color) {
                const res = [];
                const p = board[x][y];
                if (!p) return res;

                const add = (nx, ny) => {
                    if (nx < 0 || ny < 0 || nx > 7 || ny > 7) return "stop";
                    const target = board[nx][ny];
                    if (!target) { res.push({ x: nx, y: ny }); return "cont"; }
                    if (target.c !== color) { res.push({ x: nx, y: ny }); return "stop"; }
                    return "stop";
                };

                const dirs = {
                    r: [[1,0], [-1,0], [0,1], [0,-1]],
                    b: [[1,1], [1,-1], [-1,1], [-1,-1]],
                    n: [[2,1], [2,-1], [-2,1], [-2,-1], [1,2], [1,-2], [-1,2], [-1,-2]],
                    q: [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]],
                    k: [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]]
                };

                if (["r", "b", "q"].includes(p.t)) {
                    dirs[p.t].forEach(d => {
                        for (let i = 1; i < 8; i++) if (add(x + d[0] * i, y + d[1] * i) === "stop") break;
                    });
                } else if (p.t === "p") {
                    const dir = color === "w" ? 1 : -1;
                    if (y + dir >= 0 && y + dir < 8 && !board[x][y+dir]) res.push({x, y: y+dir});
                    [[1, dir], [-1, dir]].forEach(d => {
                        let nx = x + d[0], ny = y + d[1];
                        if (nx>=0 && nx<8 && ny>=0 && ny<8 && board[nx][ny] && board[nx][ny].c !== color) res.push({x:nx, y:ny});
                    });
                } else {
                    dirs[p.t].forEach(d => add(x + d[0], y + d[1]));
                }
                return res;
            }

            function click(x, y) {
                const target = board[x][y];
                if (placing) {
                    if (!target && score[turn] >= PIECES[placing].c) {
                        board[x][y] = { t: placing, c: turn };
                        score[turn] -= PIECES[placing].c;
                        placing = null; endTurn();
                    }
                } else {
                    if (target && target.c === turn) {
                        selected = { x, y }; moves = getMoves(x, y, turn);
                    } else if (selected && moves.some(m => m.x === x && m.y === y)) {
                        makeMove(selected.x, selected.y, x, y);
                    } else { selected = null; moves = []; }
                }
                draw();
            }

            function makeMove(fx, fy, tx, ty) {
                const target = board[tx][ty];
                if (target && target.t === "k") {
                    winText.textContent = (turn === "w" ? "TEBRİKLER!" : "BOT KAZANDI!");
                    overlay.style.display = "flex";
                }
                board[tx][ty] = board[fx][fy];
                board[fx][fy] = null;
                score[turn] = Math.min(10, score[turn] + 1);
                endTurn();
            }

            function endTurn() {
                selected = null; moves = [];
                turn = turn === "w" ? "b" : "w";
                draw();
                if (turn === "b") setTimeout(botPlay, 800);
            }

            function botPlay() {
                // 1. Taş Ekleme Kontrolü (Puan varsa ve şah tehlikedeyse veya rastgele)
                const types = ['q', 'r', 'n', 'b', 'p'];
                for (let type of types) {
                    if (score.b >= PIECES[type].c) {
                        let emptySquares = [];
                        for(let i=0; i<8; i++) for(let j=0; j<8; j++) if(!board[i][j]) emptySquares.push({x:i, y:j});
                        if (emptySquares.length > 0) {
                            let r = emptySquares[Math.floor(Math.random() * emptySquares.length)];
                            board[r.x][r.y] = { t: type, c: "b" };
                            score.b -= PIECES[type].c;
                            endTurn();
                            return;
                        }
                    }
                }

                // 2. Taş Hareket Ettirme (En mantıklı hamleyi bul)
                let allMoves = [];
                for(let i=0; i<8; i++) {
                    for(let j=0; j<8; j++) {
                        if(board[i][j] && board[i][j].c === "b") {
                            let mvs = getMoves(i, j, "b");
                            mvs.forEach(m => allMoves.push({fx:i, fy:j, tx:m.x, ty:m.y, target: board[m.x][m.y]}));
                        }
                    }
                }

                if (allMoves.length > 0) {
                    // Öncelik: Şah yemek > Herhangi bir taş yemek > Rastgele hamle
                    let best = allMoves.find(m => m.target && m.target.t === 'k') || 
                               allMoves.find(m => m.target) || 
                               allMoves[Math.floor(Math.random() * allMoves.length)];
                    makeMove(best.fx, best.fy, best.tx, best.ty);
                } else {
                    endTurn(); // Hamle yoksa (imkansız ama)
                }
            }

            draw();
        };
    </script>
</body>
</html>
